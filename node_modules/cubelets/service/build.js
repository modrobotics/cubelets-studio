var util = require('util');
var events = require('events');
var request = require('request');
var url = require('url');
var fs = require('fs');
var temp = require('temp');
var config = require('../config.json');

var Build = function(buildID, program, cubelet) {
	this.id = buildID;
	this.program = program;
	this.cubelet = cubelet;
	this.hex = undefined;
};

var BuildService = function() {

	events.EventEmitter.call(this);

	var builds = {};
	var compilerUrl = config['urls']['compiler'];
	var hexDownloadUrl = config['urls']['hex_download'];
	var service = this;

	var CompilerStatus = {
		COMPILING: 404,
		READY: 200
	};

	var requestCompilerStatus = function(buildID, callback) {
		request.get({
			url: compilerUrl + '/compile-result/' + buildID + '/',
			json: true
		}, function(error, response, body) {
			if (error) {
				service.emit('error', error);
				return;
			}
			var status = body['status_code'];
			callback(status);
		});
	};

	var requestHexDownload = function(buildID) {
		request.get(hexDownloadUrl + buildID, function(error, response, body) {
			if (error) {
				service.emit('error', error);
				return;
			}
			var build = builds[buildID];
			temp.open('cubehex', function(error, info) {
				if (error) {
					console.error('Error writing temp file for hex.');
					return;
				}
				fs.write(info.fd, body);
				fs.close(info.fd, function(error) {
					build.hex = info;
					service.emit('ready', build);
				});
			});
		});
	};

	var addBuild = function(buildID, program, cubelet) {
		builds[buildID] = new Build(buildID, program, cubelet);
	};

	var removeBuild = function(buildID) {
		delete builds[buildID];
	};

	this.getBuilds = function() {
		return this.builds;
	};

	this.removeBuild = function(build) {
		removeBuild(build.id);
	};

	this.requestBuild = function(program, cubelet) {
		request.post({
			url: compilerUrl + '/compile-request/',
			json: true,
			form: {
				'program_code': program.code,
				'program_title': program.name,
				'cube_id': cubelet.id
			}
		}, function(error, response, body) {
			if (error) {
				console.error('Request error.', error);
				service.emit('error', error);
				return;
			}
			if (response.statusCode != 200) {
				console.error('Bad response.', response);
				service.emit('error');
				return;
			}
			var statusCode = body['status_code'];
			if (statusCode != 200) {
				service.emit('error');
				return;
			}
			var buildID = body['u'];
			addBuild(buildID, program, cubelet);
			var intervalCount = 0;
			var intervalID = setInterval(function() {
				requestCompilerStatus(buildID, function(status) {
					if (++intervalCount > 100) {
						service.emit('error');
						clearInterval(intervalID);
						return;
					}
					switch (status) {
						case CompilerStatus.COMPILING:
							console.log('Compiling...', intervalCount);
							break;
						case CompilerStatus.READY:
							console.log('Hex ready!');
							requestHexDownload(buildID);
							clearInterval(intervalID);
							break;
						default:
							service.emit('error');
							clearInterval(intervalID);
							break;
					}
				});
			}, 3 * 1000)
		});
	};

};

util.inherits(BuildService, events.EventEmitter);

module.exports = BuildService;