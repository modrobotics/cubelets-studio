var util = require('util');
var events = require('events');
var request = require('request');
var url = require('url');
var config = require('../config.json');

var Build = function(buildID, program, cubelet) {
	this.buildID = buildID;
	this.program = program;
	this.cubelet = cubelet;
};

var BuildService = function() {

	events.EventEmitter.call(this);

	var builds = {};
	var compilerUrl = config['urls']['compiler'];
	var hexDownloadUrl = config['urls']['hex_download'];
	var service = this;

	var CompilerStatus = {
		COMPILING: 404,
		READY: 200
	};

	var requestCompilerStatus = function(buildID, callback) {
		request.get({
			url: compilerUrl + '/compile-result/' + buildID + '/',
			json: true
		}, function(error, response, body) {
			if (error) {
				service.emit('error', error);
				return;
			}
			console.log('Compile Result Response:', body);
			var status = body['status_code'];
			callback(status);
		});
	};

	var requestHexDownload = function(buildID) {
		request.get(hexDownloadUrl + buildID, function(error, response, body) {
			if (error) {
				service.emit('error', error);
				return;
			}
			console.log(response);
			console.log(body);
		});
	};

	var addBuild = function(buildID, program, cubelet) {
		builds[buildID] = new Build(buildID, program, cubelet);
	};

	var removeBuild = function(buildID) {
		delete builds[buildID];
	};

	this.requestBuild = function(program, cubelet) {
		request.post({
			url: compilerUrl + '/compile-request/',
			json: true,
			form: {
				'program_code': program.code,
				'program_title': program.name,
				'cube_id': cubelet.id
			}
		}, function(error, response, body) {
			if (error) {
				console.error('Request error.', error);
				service.emit('error', error);
				return;
			}
			if (response.statusCode != 200) {
				console.error('Bad response.', response);
				service.emit('error');
				return;
			}
			console.log('Compile Request Response:', body);
			var statusCode = body['status_code'];
			if (statusCode != 200) {
				service.emit('error');
				return;
			}
			var buildID = body['u'];
			addBuild(buildID, program, cubelet);
			var intervalCount = 0;
			var intervalID = setInterval(function() {
				requestCompilerStatus(buildID, function(status) {
					if (++intervalCount > 100) {
						service.emit('error');
						clearInterval(intervalID);
						return;
					}
					switch (status) {
						case CompilerStatus.COMPILING:
							console.log('Compiling...', intervalCount);
							break;
						case CompilerStatus.READY:
							console.log('Hex download ready!');
							requestHexDownload(buildID);
							clearInterval(intervalID);
							break;
						default:
							service.emit('error');
							clearInterval(intervalID);
							break;
					}
				});
			}, 5 * 1000)
		});
	};

};

util.inherits(BuildService, events.EventEmitter);

module.exports = BuildService;