var events = require('events');
var util = require('util');
var async = require('async');
var Hash = require('hashish');
var ResponseParser = require('./parser');
var ResponseTypes = require('./config.json')['responses'];
var Encoder = require('./encoder');
var Decoder = require('./decoder');

// Flash targets
var Targets = {
  PIC:'pic',
  AVR:'avr'
};

var FlashLoader = function(cubelet, stream, encoding) {
  
  events.EventEmitter.call(this);

  // Origin cubelet in construction
  this.cubelet = cubelet;

  // Create a new response parser
  var parser = new ResponseParser(encoding);

  // Begin parsing responses
  stream.on('data', function(data) {
    console.log('Data', data);
    parser.parse(data);
  });

  var emitter = this;

  var version = cubelet.currentFirmwareVersion;
  var capabilities = {
    'reset': (version >= 3.1)
  };

  this.load = function(program, cubelet) {
    // Ensure program is valid
    if (!program.valid) {
      emitter.emit('error', new Error('Invalid program.'));
      return;
    }

    // Check that cubelet exists
    if (!cubelet) {
      emitter.emit('error', new Error('No cubelet.'));
      return;
    }

    // Check that cubelet has a valid target MCU
    var target = cubelet.mcu;
    if (!Hash(Targets).detect(function(value) { return value === target })) {
      emitter.emit('error', new Error('Unknown flash target \'' + target + '\'.'));
      return;
    }

    // Parellelizes two tasks
    function parallel(tasks) {
      return function(callback) {
        async.parallel(tasks, callback);
      }
    }

    // Waits for a given response
    function waitForCode(code, timeout) {
      return function(callback) {
        // Listen to raw data from parser
        parser.setRawMode(true);
        parser.on('raw', listen);

        // Set a timeout for receiving the data
        var timer = setTimeout(function() {
          parser.removeListener('raw', listen);
          callback(new Error("Timed out waiting for '" + code + "'."));
        }, timeout);

        function listen(data) {
          // Check first byte of raw data
          if (data.readUInt8(0) === code.charCodeAt(0)) {
            parser.removeListener('raw', listen);
            clearTimeout(timer);
            callback(null);
          }
        }
      };
    }

    // Sends data and drains the buffer
    function send(data) {
      return function(callback) {
        stream.write(data, function(error) {
          if (error) {
            callback(error);
            return;
          }
          stream.drain(callback);
        });
      }
    }

    // Sends a single-character code
    function sendCode(code) {
      return send(new Buffer([code.charCodeAt(0)]));
    }

    // Drains the buffer
    function drain(callback) {
      stream.drain(callback);
    }

    // Waits for a given interval
    function wait(interval) {
      return function(callback) {
        setTimeout(function() {
          callback(null);
        }, interval);
      };
    }

    function sendResetCommand(callback) {
      async.series([
        parallel([
          send(new Buffer([
            0x15,
            0x3A,
            0x95,
            0x68,
            0xC1,
            0x9A,
            0x84
          ])),
          waitForCode('?', 30000)
        ]),
        send(new Buffer([
          0x59
        ]))
      ], callback);
    }

    // Set parser to raw mode
    parser.setRawMode(true);

    function loadDeviceBuffer() {
      function sendReadyCommand(callback) {
        sendCode('3')(callback);
      }
      function sendProgramChecksum(callback) {
        send(new Buffer([
          '8'.charCodeAt(0),
          program.checksum.xor,
          program.checksum.sum
        ]))(callback);
      }
      function sendProgramData(callback) {
        // Send each chunk in a series
        var chunks = [];
        var chunkSize = 200;
        var chunkInterval = 80;
        var progress = 0;
        function addChunk() {
          var data = program.readData(chunkSize);
          if (data) {
            chunks.push(send(data), function(callback) {
              emitProgress('upload', {
                progress: progress += data.length,
                total: program.data.length
              });
              callback(null);
            }, wait(chunkInterval));
          }
          return !!data;
        }
        while (addChunk());
        async.series(chunks, callback);
      }
      function sendFlashCommand(callback) {
        switch (target) {
          case Targets.AVR:
            var encodedID = Encoder.encodeID(cubelet.id);
            async.series([
              parallel([
                send(new Buffer([
                  'W'.charCodeAt(0),
                  encodedID.readUInt8(0),
                  encodedID.readUInt8(1),
                  encodedID.readUInt8(2)
                ])),
                waitForCode('R', 5000)
              ]),
              send(new Buffer([
                'M'.charCodeAt(0),
                encodedID.readUInt8(0),
                encodedID.readUInt8(1),
                encodedID.readUInt8(2),
                program.pageCount,
                program.lastPageSize
              ]))
            ], callback);
            break;
          case Targets.PIC:
            var encodedID = Encoder.encodeID(cubelet.id);
            send(new Buffer([
              'L'.charCodeAt(0),
              encodedID.readUInt8(0),
              encodedID.readUInt8(1),
              encodedID.readUInt8(2)
            ]))(callback);
            break;
          default:
            callback(new Error('Flashing target \'' + target + '\' is not supported.'));
            break;
        }
      }
      // Waits for flashing to complete
      function waitForFlash(timeout) {
        return function(callback) {
          // Listen to response from parser
          parser.setRawMode(false);
          parser.on('response', listen);

          // Timeout expiration handler
          function expire() {
            parser.removeListener('response', listen);
            callback(new Error("Timed out waiting for flash to complete."));
          }

          // Set a timeout for receiving response
          var timer = setTimeout(expire, timeout);

          function listen(response) {
            switch (response.type.code) {
              case ResponseTypes['FLASH_PROGRESS'].code:
                clearTimeout(timer);
                emitProgress('flash', {
                  progress: 20 * response.progress,
                  total: program.lineCount
                });
                timer = setTimeout(expire, timeout);
                break;
              case ResponseTypes['FLASH_COMPLETE'].code:
                parser.removeListener('response', listen);
                clearTimeout(timer);
                emitProgress('flash', {
                  total: program.lineCount
                });
                callback(null);
                break;
            }
          }
        };
      }
      function waitForSafeCheck(timeout) {
        return function(callback) {
          async.series([
            wait(1000),
            sendCode('`'),
            wait(5000),
            parallel([
              sendCode('1'),
              waitForCode('Z', timeout)
            ])
          ], callback);
        };
      }
      async.series([
        drain,
        parallel([
          sendReadyCommand,
          waitForCode('4', 5000)
        ]),
        parallel([
          sendProgramChecksum,
          waitForCode('R', 5000)
        ]),
        parallel([
          sendProgramData,
          waitForCode('Y', 30000)
        ]),
        sendFlashCommand,
        waitForFlash(5000),
        waitForSafeCheck(5000)
      ].concat(capabilities['reset'] ? [
        sendResetCommand
      ]:[]), function(error) {
        parser.setRawMode(false);
        emitLoadResult(error);
      });
    }

    function loadDevice() {
      function sendDisableAutomapCommand(callback) {
        sendCode('5')(callback);
      }
      function sendReadyCommand(callback) {
        var encodedID = Encoder.encodeID(cubelet.id);
        send(new Buffer([
          'T'.charCodeAt(0),
          encodedID.readUInt8(0),
          encodedID.readUInt8(1),
          encodedID.readUInt8(2)
        ]))(callback);
      }
      function sendProgramPages(callback) {
        var pages = program.getPages();
        async.series((function() {
          var chunks = [];
          for (var p = 0; p < pages.length; ++p) {
            (function(p) {
              var page = pages[p];
              chunks.push(parallel([
                send(page),
                waitForCode('G', 5000),
                function(callback) {
                  emitProgress('flash', {
                    progress: p + 1,
                    total: pages.length
                  });
                  callback(null);
              }]));
            })(p);
          }
          chunks.push(send(new Buffer([
            0xFE,
            0xFD
          ])));
          return chunks;
        })(), callback);
      }
      async.series([
        drain,
        parallel([
          sendReadyCommand,
          waitForCode('!', 30000)
        ]),
        parallel([
          sendProgramPages,
          waitForCode('@', 90000)
        ]),
        wait(1000),
        parallel([
          sendCode('#'),
          waitForCode('%', 30000)
        ])
      ].concat(capabilities['reset'] ? [
        sendResetCommand
      ]:[]), function(error) {
        parser.setRawMode(false);
        emitLoadResult(error);
      });
    }

    function emitProgress(status, e) {
      e.progress = (e.progress === undefined) ? e.total : e.progress;
      e.percent = parseInt(100.0 * ((e.total > 0) ? (e.progress / e.total) : 0.5));
      emitter.emit(status, e);
    }

    function emitLoadResult(error) {
      if (error) {
        emitter.emit('error', error);
        return;
      }
      emitter.emit('success');
    }

    if (cubelet.id === this.cubelet.id) {
      loadDevice();
    }
    else {
      loadDeviceBuffer();
    }
  }
};

util.inherits(FlashLoader, events.EventEmitter);
module.exports = FlashLoader;
module.exports.Targets = Targets;