var events = require('events');
var util = require('util');
var async = require('async');
var Hash = require('hashish');
var ResponseParser = require('./parser');
var ResponseTypes = require('./config.json')['responses'];
var Encoder = require('./encoder');
var Decoder = require('./decoder');

var FlashLoader = function(cubelet, stream, encoding) {
    
    events.EventEmitter.call(this);

    // Origin cubelet in construction
    this.cubelet = cubelet;

    // Flash targets
    var Target = {
        PIC:'pic',
        AVR:'avr',
        BT:'bt'
    };

    // Create a new response parser
    var parser = new ResponseParser(encoding);

    // Begin parsing responses
    stream.on('data', function(data) {
        parser.parse(data);
    });

    var emitter = this;

    var version = cubelet.currentFirmwareVersion;
    var capabilities = {
        'reset': (version >= 3.1)
    };

    this.load = function(program, cubelet) {
        // Ensure program is valid
        if (!program.valid) {
            emitter.emit('error', new Error('Invalid program.'));
            return;
        }

        // Check that cubelet exists
        if (!cubelet) {
            emitter.emit('error', new Error('No cubelet.'));
            return;
        }

        // Check that cubelet has a valid target MCU
        var target = cubelet.mcu;
        if (!Hash(Target).detect(function(value) { return value === target })) {
            emitter.emit('error', new Error('Unknown flash target \'' + target + '\'.'));
            return;
        }

        // Waits for a given response
        function waitFor(code, timeout) {
            return function(callback) {
                // Listen to raw data from parser
                parser.setRawMode(true);
                parser.on('raw', listen);

                // Set a timeout for receiving the data
                var timer = setTimeout(function() {
                    parser.removeListener('raw', listen);
                    callback(new Error("Timed out waiting for '" + code + "'."));
                }, timeout);

                function listen(data) {
                    // Check first byte of raw data
                    if (data.readUInt8(0) === code.charCodeAt(0)) {
                        parser.removeListener('raw', listen);
                        clearTimeout(timer);
                        callback(null);
                    }
                }
            };
        }

        // Sends data and drains the buffer
        function send(data) {
            return function(callback) {
                stream.write(data, function(error) {
                    if (error) {
                        callback(error);
                        return;
                    }
                    stream.drain(callback);
                });
            }
        }

        // Drains the buffer
        function drain(callback) {
            stream.drain(callback);
        }

        // Waits for a given interval
        function wait(interval) {
            return function(callback) {
                setTimeout(function() {
                    callback(null);
                }, interval);
            };
        }

        // Waits for flashing to complete
        function waitForFlash(timeout) {
            return function(callback) {
                // Listen to response from parser
                parser.setRawMode(false);
                parser.on('response', listen);

                // Timeout expiration handler
                function expire() {
                    parser.removeListener('response', listen);
                    callback(new Error("Timed out waiting for flash to complete."));
                }

                // Set a timeout for receiving response
                var timer = setTimeout(expire, timeout);

                function listen(response) {
                    switch (response.type.code) {
                        case ResponseTypes['FLASH_PROGRESS'].code:
                            clearTimeout(timer);
                            emitProgress('flash', {
                                progress: 20 * response.progress,
                                total: program.lines
                            });
                            timer = setTimeout(expire, timeout);
                            break;
                        case ResponseTypes['FLASH_COMPLETE'].code:
                            parser.removeListener('response', listen);
                            clearTimeout(timer);
                            emitProgress('flash', {
                                total: program.lines
                            });
                            callback(null);
                            break;
                    }
                }
            };
        }

        // Emits a progress message
        function emitProgress(status, e) {
            e.progress = e.progress || e.total;
            e.percent = parseInt(100.0 * ((e.total > 0) ? (e.progress / e.total) : 0.5));
            emitter.emit(status, e);
        }

        function sendReadyCommand(callback) {
            send(new Buffer([
                '3'.charCodeAt(0)
            ]))(callback);
        }

        function sendChecksumData(callback) {
            send(new Buffer([
                '8'.charCodeAt(0),
                program.checksum.xor,
                program.checksum.sum
            ]))(callback);
        }

        function sendProgramData(callback) {
            // Send each chunk in a series
            var chunks = [];
            var chunkSize = 200;
            var chunkInterval = 80;
            var progress = 0;
            function addChunk() {
                var data = program.readData(chunkSize);
                if (data) {
                    chunks.push(send(data), function(callback) {
                        emitProgress('upload', {
                            progress: progress += data.length,
                            total: program.data.length
                        });
                        callback(null);
                    }, wait(chunkInterval));
                }
                return !!data;
            }
            while (addChunk());
            async.series(chunks, callback);
        }

        function sendFlashCommand(callback) {
            switch (target) {
                case Target.AVR:
                    var encodedID = Encoder.encodeID(cubelet.id);
                    async.series([
                        send(new Buffer([
                            'W'.charCodeAt(0),
                            encodedID.readUInt8(0),
                            encodedID.readUInt8(1),
                            encodedID.readUInt8(2)
                        ])),
                        waitFor('R', 30000),
                        send(new Buffer([
                            'M'.charCodeAt(0),
                            encodedID.readUInt8(0),
                            encodedID.readUInt8(1),
                            encodedID.readUInt8(2),
                            program.pageCount,
                            program.lastPageSize
                        ]))
                    ], callback);
                    break;
                case Target.PIC:
                    var encodedID = Encoder.encodeID(cubelet.id);
                    send(new Buffer([
                        'L'.charCodeAt(0),
                        encodedID.readUInt8(0),
                        encodedID.readUInt8(1),
                        encodedID.readUInt8(2)
                    ]))(callback);
                    break;
                case Target.BT:
                    callback(new Error('Bluetooth flashing not yet supported.'));
                    break;
            }
        }

        function sendCheckSafeCommand(callback) {
            async.series([
                wait(1000),
                send('`'),
                wait(1000),
                send('1')
            ], callback);
        }

        function sendResetCommand(callback) {
            parser.setRawMode(false);
            async.series([
                send(new Buffer([
                    0x15,
                    0x3A,
                    0x95,
                    0x68,
                    0xC1,
                    0x9A,
                    0x84
                ])),
                waitFor('?', 30000),
                send(new Buffer([
                    0x59
                ]))
            ], callback);
        }

        // Set parser to raw mode
        parser.setRawMode(true);

        // Begin flash loading sequence
        async.series([
            drain,
            sendReadyCommand,
            waitFor('4', 30000),
            sendChecksumData,
            waitFor('R', 30000),
            sendProgramData,
            waitFor('Y', 30000),
            sendFlashCommand,
            waitForFlash(30000),
            sendCheckSafeCommand,
            waitFor('Z', 30000)
        ].concat(capabilities['reset'] ? [
            sendResetCommand
        ]:[]), function(error) {
            // Reset
            sendResetCommand(function() {
                parser.setRawMode(false);
            });

            if (error) {
                // An error occurred during flashing.
                emitter.emit('error', error);
                return;
            }

            // Flash was successful.
            emitter.emit('success');
        });
    }
};

util.inherits(FlashLoader, events.EventEmitter);
module.exports = FlashLoader;
